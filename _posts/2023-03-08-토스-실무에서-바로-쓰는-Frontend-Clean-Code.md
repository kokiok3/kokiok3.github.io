---
home:
title: 토스 | 실무에서 바로 쓰는 Frontend Clean Code
date: 2023-03-08
categories: [개발자 컨퍼런스, 토스]
tags: [토스, 개발자 컨퍼런스, 클린코드] # TAG names should always be lowercase
pin: true
---

> 클린 코드는 짧은 코드가 아니다. 원하는 로직을 빠르게 찾을 수 있는 코드이다.

***

# 실무에서의 클린 코드의 의의 = 유지 보수 시간의 단축

우리는 보통 코드를 새로 짜는 것보다 수정하거나 추가하는 일을 많이 한다.  
하지만 코드를 계속 추가하다 보면 지뢰 코드가 되기 십상이다.

![image](https://user-images.githubusercontent.com/84312457/224027682-bb6dc37b-faed-4dfc-b19b-0a585d868e8a.png)

**지뢰 코드**는 흐름 파악이 ❌, 도메인 맥락 표현이 ❌, 동료에게 물어봐야 알 수 있는 코드이다.

<br>

## 우리가 주목할 것은 안일한 코드 추가의 함정이다.  
기능 추가 전에는 깔끔한 코드였다. 하지만 기능 추가 후에 더러워지는 경우가 있다.
바로, 하나의 목적인 코드가 흩뿌려진 경우이다. 이러한 경우 점점 지뢰코드가 되는 것이다.  
<br>
앞서 말한 지뢰 코드는 기능을 세부 목적별로 구분함으로 개선할 수 있다. 자 그럼 지뢰코드를 만들지 않고 클린코드를 짤 수 있는 방법을 알아보자.

<br>

## 클린 코드 ≠ 짧은 코드
> 클린 코드 = 원하는 로직을 빠르게 찾을 수 있는 코드이다.

👇아래에 클린 코드를 위한 방법 3가지가 있다.

| 클린 코드를 위한 방법 3 |
| :---: |
| 응집도 |
| 단일 책임 |
| 추상화 |

<br>

## 응집도
* 하나의 목적을 가진 코드가 흩뿌려져 있을 때 응집도를 높여 뭉친다.
* 핵심 구현만 빼놓고 세부 구현은 안쪽에(컴포넌트) 뭉친다.
  
이러한 특징은 선언적 프로그래밍을 갖는다. 코드에서 **무엇을 해야 하는지만 알려주고 나머지는 세부 구현한다.** 장점으로 코드 이해가 쉽다.
  
  ```javascript
// 선언적 프로그래밍 예시
<Popup 
    onSubmit={회원가입}
    onSuccess={프로필로이동}
>
```
```javascript
// 명령형 프로그래밍
// 단점으로 코드 파악이 어렵다.
<Popup>
    <button onClick={async () => {
        const res = await 회원가입();
        if(res.success){
            프로필로이동();
        }
    }}>전송</button>
</Popup>
```
<br>

## 단일책임
* 중요 포인트가 모두 담겨있는 함수명을 가져야 한다.  
* 한 가지 일만 하는 명확한 함수명 / 한 가지 일만 하는 기능성 컴포넌트 
* [영어 이름이 너무 길 때 / 상수를 직관적으로 보고 싶을 때 / 복잡한 조건문이 많을 때]는 한글 이름이 유용하다. 

**👇아래의 코드는 위험한 함수명 예시이다.**  
답은 코드 아래에 있으니 생각해 볼 것!
```javascript

async function handle질문제출() {
    const 약관동의 = await 약관동의_받아오기();
    if(!약관동의){
        await 약관동의_팝업열기();
    }
    await 질문전송(questionValue);
    alert("질문이 등록되었어요.");
}
```
<br>
>답: 중요 포인트가 모두 담겨있지 않다. 함수명은 '질문 제출'이지만 내용에는 약관 동의와 질문 제출이 있어서 적절하지 않은 함수명이다. 만약 위의 코드에서 기능을 추가한다면 미래의 지뢰 코드가 될 수 있다.
**이를 위해 한 가지 일만 하는 함수로 나누자.**

<br>

### 추상화

* 핵심 개념을 필요한 만큼 노출(추상화) 한다.

피카소의 소 그림을 보면 제일 왼쪽의 소처럼 구체적인 '소'에서, 디테일을 점차 지워서 맨 오른쪽의 소처럼 큰 특징만 표현한다.
![image](https://user-images.githubusercontent.com/84312457/224037448-cbbd21ca-e5e8-4140-95d5-5f0ff7b0c5e7.png)

* 코드 추상화 : 컴포넌트  

```javascript
// 중요한 개념만 남기고 추상화
<Popup 
    onSubmit={회원가입}
    onSuccess={프로필로이동}
>
```
```javascript
// 모두 구현
<Popup>
    <button onClick={async () => {
        const res = await 회원가입();
        if(res.success){
            프로필로이동();
        }
    }}>전송</button>
</Popup>
```
<br>

* 코드 추상화 : 함수  

```javascript
// planner 라벨을 얻는 코드 세부 구현
const planner = await fetchPlanner(plannerId)
const label = planner.new ? '새로운 상담사' : '연결중인 상담사'
```
```javascript
// 중요 개념을 함수 이름에 담아 추상화
const label = await getPlannerLabel(plannerId)
```
<br>

* 주의할 점으로는 한 레벨의 코드에서 추상화 수준이 다르면 코드 파악이 어렵다.  
  * 전체적인 코드가 어느 수준으로 구체적으로 기술된지 파악할 수 없다.


```javascript

// 각기 다른 추상화 수준 
<Title>별점 매겨주세요</Title>   // 높은 추상화
<div>                           // 낮은 추상화
    {STARS.map(()=><Star />)}
</div>
<Reviews />                    // 높은 추상화
{rating !== 0 && (             // 중간 추상화
    <>
        <Agreement />
        <Button rating={rating} />
    </>
)}
```

```javascript

// 동일한 추상화 수준 
<Title>별점 매겨주세요</Title>
<Stars />
<Reviews />                 
<AgreementButton show={rating !== 0} />
```
<br>

***

# 내일부터 할 수 있는 클린 코드를 위한 행동
1. **담대하게 기존 코드 수정하기**  
    a. <small>부모의 브랜치를 따서 리팩토링해보기</small>

2. **큰 그림 보는 연습하기**  
    a. <small>지금은 괜찮은 코드여도 기능 추가 후에 더러워질 수 있다.</small>  
    b. <small>또는 기능 추가 자체가 클린해도 큰 그림으로는 어지러운 코드일 수 있다.</small>
   
3. **팀과 공감대 형성하기**  
    a. <small>리뷰를 하자</small>  
    b. <small>명시적으로 코드에 대해 이야기하는 시간이 필요하다.</small>
   
4. **문서로 적어보기**  
   a. <small>향후 위험한 점</small>  
   b. <small>어떻게 개선할지</small>

   <br>

***
# 클린 코드를 적용해 보았다.
입사 전부터 있던 코드로 우연한 계기로 해당 코드를 수정할 일이 생겼다.  
하지만 해당 함수를 이해하는것 부터 오래 걸렸는데, 이번 강의를 듣고 리팩토링을 진행해 보았다.

### 리팩토링 전
### 리팩토링 후